# Encoding: UTF-8
# File: coco.py
# Creation: Tuesday December 29th 2020
# Author: arthurdjn
# ------
# Copyright (c) 2020, Makina Corpus


# Basic imports
from tqdm import tqdm
from pathlib import Path
from datetime import datetime
import json
from PIL import Image, ImageDraw
from shapely.geometry import Polygon
import numpy as np
import random

# Geolabel Maker
from geolabel_maker.annotations.functional import extract_categories
from geolabel_maker.vectors import Color
from ._utils import extract_paths


class COCO:
    r"""Defines an annotation for `Common Object in Context <http://cocodataset.org/>`__. 
    It follows the format used by Microsoft for ``COCO`` annotation.

    * :attr:`info` (dict, optional): Description of the annotation (metadata).

    * :attr:`images` (list): List of dictionaries containing metadata for the images in context.

    * :attr:`categories` (list): List of dictionaries containing the description of the categories used.

    * :attr:`annotations` (list): List of dictionaries containing the segmentation of an object associated to an image.

    """

    def __init__(self, images, categories, annotations, info=None):
        super().__init__()
        self.images = images
        self.categories = categories
        self.annotations = annotations
        self.info = info or {
            "description": "Auto-generated by Geolabel-Maker",
            "date_created": datetime.now().strftime("%Y/%m/%d")
        }

    @classmethod
    def open(cls, filename):
        """Open ``COCO`` annotations. The file must be in the `JSON` format.

        Args:
            filename (str): Name of the file to read.

        Returns:
            COCO
            
        Examples:
            >>> annotations = COCO.open("coco.json")
        """
        with open(filename, "r") as f:
            data = json.load(f)
        images = data.get("images", None)
        categories = data.get("categories", None)
        annotations = data.get("annotations", None)
        info = data.get("info", None)
        return COCO(images, categories, annotations, info)

    @classmethod
    def build(cls, images=None, categories=None, labels=None,
              pattern="*.*", root=None, is_crowd=False, **kwargs):
        r"""Generate a ``COCO`` annotation from a ``Dataset``.

        .. seealso::
            The provided dataset must contains a set of georeferenced images and categories (vectorized geometries).
            See ``Dataset`` for further details.

        Args:
            dataset (Dataset): The dataset containing the images and categories.
            zoom (int, optional): Zoom level used to generate the annotations.
            is_crowd (bool, optional): Defaults to ``False``.

        Returns:
            COCO
        """
        # Map the categories and their ids
        category2id = {category.name: i for i, category in enumerate(categories)}
        images_paths = extract_paths(images, pattern=pattern)
        labels_paths = extract_paths(labels, pattern=pattern)

        def get_annotations():
            # Retrieve the annotations (i.e. geometry / categories)
            coco_annotations = []
            annotation_id = 0
            couple_labels = list(zip(images_paths, labels_paths))
            pbar = tqdm(total=len(couple_labels), desc="Build Annotations", leave=True, position=0)
            for image_id, (image_path, label_path) in enumerate(couple_labels):
                for category in extract_categories(label_path, categories, **kwargs):
                    category_id = category2id[category.name]
                    for _, row in category.data.iterrows():
                        try:
                            polygon = row.geometry
                            # Get annotation elements
                            segmentation = np.array(polygon.exterior.coords).ravel().tolist()
                            x, y, max_x, max_y = polygon.bounds
                            width = max_x - x
                            height = max_y - y
                            bbox = (x, y, width, height)
                            area = polygon.area
                            # Make annotation format
                            coco_annotations.append({
                                "segmentation": [segmentation],
                                "iscrowd": int(is_crowd),
                                "image_id": image_id,
                                "image_name": str(image_path),
                                "category_id": category_id,
                                "id": annotation_id,
                                "bbox": bbox,
                                "area": area,
                            })
                            annotation_id += 1
                        except Exception as error:
                            print(label_path, error)
                pbar.update(1)
            return coco_annotations

        def get_categories():
            # Create an empty categories' dictionary
            coco_categories = []
            pbar = tqdm(total=len(categories), desc="Build Categories", leave=True, position=0)
            for category in categories:
                category_id = category2id[category.name]
                coco_categories.append({
                    "id": category_id,
                    "name": category.name,
                    "color": category.color,
                    "file_name": str(category.filename),
                    "supercategory": category.name
                })
                pbar.update(1)
            return coco_categories

        def get_images():
            # Retrieve image paths / metadata
            coco_images = []
            pbar = tqdm(total=len(images_paths), desc="Build Images", leave=True, position=0)
            for image_id, image_path in enumerate(images_paths):
                # get image info
                img = Image.open(image_path)
                width, height = img.size
                # create image description
                coco_images.append({
                    "id": image_id,
                    "width": width,
                    "height": height,
                    "file_name": str(image_path)
                })
                pbar.update(1)
            return coco_images

        # Create the annotation as a dict
        coco_categories = get_categories()
        coco_images = get_images()
        coco_annotations = get_annotations()

        return COCO(coco_images, coco_categories, coco_annotations)

    def to_dict(self):
        return {
            "info": self.info,
            "images": self.images,
            "categories": self.categories,
            "annotations": self.annotations
        }

    def save(self, filename):
        """Save the `COCO` annotation in a `JSON` format.

        Args:
            filename (str): Name of the annotation file.

        Examples:
            >>> annotations = COCO.build(images="data/mosaics/images", labels="data/mosaics/labels", categories=dataset.categories)
            >>> annotations.save("coco.json")
        """
        with open(filename, "w") as f:
            json.dump(self.to_dict(), f, indent=4)

    def get_image(self, image_id):
        """Get the image from its id.

        Args:
            image_id (int): ID of the image to be retrieved.

        Returns:
            PIL.Image

        Examples:
            >>> annotations = COCO.open("coco.json")
            >>> image = annotations.get_image(19)
        """
        for image in self.images:
            if image["id"] == image_id:
                return Image.open(image["file_name"]).convert("RGB")
        return None

    def get_masks(self, image_id):
        """Get the list of masks associated to an image.

        Args:
            image_id (int): ID of the image.

        Returns:
            list: List of dictionary containing the segmentation.

        Examples:
            >>> annotations = COCO.open("coco.json")
            >>> masks = annotations.get_masks(19)
        """
        masks = []
        for annotation in self.annotations:
            if annotation["image_id"] == image_id:
                masks.append(annotation)
        return masks

    def show(self, image_id=None, colors=None, blend_percentage=0.7):
        """Show the superposition of the segmentation map (labels) on an image.

        Args:
            image_id (int, optional): ID of the image to be displayed. 
                If ``None``, will display a random image. Defaults to ``None``.
            colors (dict, optional): Dictionary of colors indexed by categories' ID. 
                If ``None``, will display each label in a random color. Defaults to ``None``.
            blend_percentage (float, optional): Blending perecentage. Defaults to 0.7.

        Returns:
            PIL.Image

        Examples:
            >>> annotations = COCO.open("coco.json")
            >>> annotations.show(19)
        """
        # Create a map of colors / categories
        colors = colors or {}
        colors = {int(key): value for key, value in colors.items()}
        for category in self.categories:
            if not category["id"] in colors.keys():
                colors[category["id"]] = Color.random().to_hex()

        # Find masks associated to image_id
        if image_id is None:
            image_id = random.choice([image["id"] for image in self.images])
        image = self.get_image(image_id)
        masks = self.get_masks(image_id)
        for mask in masks:
            image_mask = image.copy()
            draw = ImageDraw.Draw(image)
            segmentation = mask["segmentation"][0]
            x = segmentation[::2]
            y = segmentation[1::2]
            polygon = Polygon(np.column_stack((x, y)))
            color = colors[mask["category_id"]]
            draw.polygon(list(polygon.exterior.coords), fill=color)
            image = Image.blend(image_mask, image, blend_percentage)
        return image

    def __repr__(self):
        return f"COCO(images={len(self.images)}, categories={len(self.categories)}, annotations={len(self.annotations)})"
